"""\nLIVING ENVIRONMENT ENGINE - WEATHER CLIENT\nOpenWeatherMap API integration with caching and error handling.\n\nAPI Documentation: https://openweathermap.org/current\nFree tier: 1,000 calls/day (enough for 15-min updates for 96 users)\n\nEvidence Grade: E5 (Direct meteorological observation)\n"""\n\nfrom __future__ import annotations\nimport os\nimport time\nimport logging\nfrom typing import Optional\nimport requests\n\nfrom core.environment.types import WeatherCondition\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Weather Client\n# ---------------------------------------------------------------------------\n\nclass OpenWeatherMapClient:\n    \"\"\"\n    Wrapper for OpenWeatherMap API with caching and error handling.\n    \n    Usage::\n        client = OpenWeatherMapClient(api_key=\"your_key\", update_interval_seconds=900)\n        weather = client.current(29.4241, -98.4936)  # San Antonio, TX\n        print(weather.condition)  # WeatherCondition.CLEAR\n    \"\"\"\n    \n    BASE_URL = \"https://api.openweathermap.org/data/2.5/weather\"\n    \n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        update_interval_seconds: int = 900,  # 15 minutes\n    ) -> None:\n        self.api_key = api_key or os.getenv(\"OPENWEATHERMAP_API_KEY\", \"\")\n        if not self.api_key:\n            logger.warning(\"No OpenWeatherMap API key provided â€” weather will fallback to CLEAR\")\n        \n        self.update_interval = update_interval_seconds\n        self._cache: dict = {}  # Keyed by (lat, lon)\n        self._last_fetch: dict = {}  # Keyed by (lat, lon)\n    \n    def current(self, lat: float, lon: float) -> WeatherData:\n        \"\"\"\n        Fetch current weather for given coordinates.\n        Uses cache if available and not expired.\n        \n        Returns WeatherData object (see below).\n        \"\"\"\n        cache_key = (round(lat, 2), round(lon, 2))  # 2 decimal = ~1km precision\n        \n        # Check cache\n        now = time.time()\n        if cache_key in self._cache:\n            last_fetch = self._last_fetch.get(cache_key, 0)\n            if now - last_fetch < self.update_interval:\n                logger.debug(f\"Weather cache hit for {cache_key}\")\n                return self._cache[cache_key]\n        \n        # Fetch from API\n        try:\n            data = self._fetch_from_api(lat, lon)\n            weather = self._parse_response(data)\n            \n            # Update cache\n            self._cache[cache_key] = weather\n            self._last_fetch[cache_key] = now\n            \n            logger.info(f\"Weather updated for {cache_key}: {weather.condition.value}\")\n            return weather\n        \n        except Exception as e:\n            logger.error(f\"Weather API error: {e}\")\n            # Return fallback\n            if cache_key in self._cache:\n                logger.info(\"Using stale weather cache\")\n                return self._cache[cache_key]\n            else:\n                logger.warning(\"Returning fallback CLEAR weather\")\n                return WeatherData.fallback()\n    \n    def _fetch_from_api(self, lat: float, lon: float) -> dict:\n        \"\"\"Make HTTP request to OpenWeatherMap.\"\"\"\n        if not self.api_key:\n            raise ValueError(\"No API key configured\")\n        \n        params = {\n            \"lat\": lat,\n            \"lon\": lon,\n            \"appid\": self.api_key,\n            \"units\": \"metric\",  # Celsius\n        }\n        \n        response = requests.get(self.BASE_URL, params=params, timeout=10)\n        response.raise_for_status()\n        return response.json()\n    \n    def _parse_response(self, data: dict) -> WeatherData:\n        \"\"\"Parse OWM JSON response into WeatherData.\"\"\"\n        # Extract main weather condition code\n        weather_id = data[\"weather\"][0][\"id\"]\n        condition = self._map_condition_code(weather_id)\n        \n        # Extract metrics\n        main = data[\"main\"]\n        wind = data.get(\"wind\", {})\n        \n        # UV index requires separate API call (not in current weather)\n        # For now, estimate from cloud cover + time of day\n        clouds = data.get(\"clouds\", {}).get(\"all\", 0)\n        uv_estimate = max(0, 8 * (1 - clouds / 100))  # Rough estimate\n        \n        return WeatherData(\n            condition=condition,\n            temperature_c=main[\"temp\"],\n            humidity=main[\"humidity\"] / 100,  # Convert to 0-1\n            wind_speed_ms=wind.get(\"speed\", 0),\n            uv_index=uv_estimate,\n        )\n    \n    def _map_condition_code(self, code: int) -> WeatherCondition:\n        \"\"\"\n        Map OWM condition code to WeatherCondition enum.\n        \n        OWM Code Groups:\n        - 2xx: Thunderstorm\n        - 3xx: Drizzle\n        - 5xx: Rain\n        - 6xx: Snow\n        - 7xx: Atmosphere (fog, mist, etc.)\n        - 800: Clear\n        - 80x: Clouds\n        \"\"\"\n        if 200 <= code < 300:\n            return WeatherCondition.STORM\n        elif 300 <= code < 400:\n            return WeatherCondition.RAIN\n        elif 500 <= code < 600:\n            if code >= 502:  # Heavy rain\n                return WeatherCondition.HEAVY_RAIN\n            return WeatherCondition.RAIN\n        elif 600 <= code < 700:\n            return WeatherCondition.SNOW\n        elif 700 <= code < 800:\n            return WeatherCondition.FOG\n        elif code == 800:\n            return WeatherCondition.CLEAR\n        elif code == 801 or code == 802:\n            return WeatherCondition.PARTLY_CLOUDY\n        else:  # 803, 804\n            return WeatherCondition.CLOUDY\n\n# ---------------------------------------------------------------------------\n# Weather Data Container\n# ---------------------------------------------------------------------------\n\nclass WeatherData:\n    \"\"\"Container for current weather state.\"\"\"\n    \n    def __init__(\n        self,\n        condition: WeatherCondition,\n        temperature_c: float,\n        humidity: float,\n        wind_speed_ms: float,\n        uv_index: float,\n    ) -> None:\n        self.condition = condition\n        self.temperature_c = temperature_c\n        self.humidity = humidity\n        self.wind_speed_ms = wind_speed_ms\n        self.uv_index = uv_index\n    \n    @classmethod\n    def fallback(cls) -> WeatherData:\n        \"\"\"Return neutral fallback weather when API unavailable.\"\"\"\n        return cls(\n            condition=WeatherCondition.CLEAR,\n            temperature_c=20.0,\n            humidity=0.5,\n            wind_speed_ms=2.0,\n            uv_index=5.0,\n        )\n