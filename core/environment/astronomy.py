"""\nLIVING ENVIRONMENT ENGINE - ASTRONOMY CALCULATIONS\nSolar position, sunrise/sunset, and seasonal determination.\n\nUses NOAA Solar Calculator algorithms for astronomical accuracy.\nEvidence Grade: E5 (Celestial mechanics, SI units)\n"""\n\nfrom __future__ import annotations\nimport math\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Tuple\n\nfrom core.environment.types import TimePhase, Season\n\n# ---------------------------------------------------------------------------\n# Solar Calculations (NOAA Algorithm)\n# ---------------------------------------------------------------------------\n\nclass AstronomyCalculator:\n    \"\"\"\n    Calculate solar position and seasonal information.\n    \n    Uses NOAA Solar Calculator algorithms:\n    https://www.esrl.noaa.gov/gmd/grad/solcalc/\n    \"\"\"\n    \n    def solar_position(\n        self,\n        lat: float,\n        lon: float,\n        dt: datetime\n    ) -> dict:\n        \"\"\"\n        Calculate sun altitude and azimuth for given location/time.\n        \n        Args:\n            lat: Latitude in degrees (-90 to 90)\n            lon: Longitude in degrees (-180 to 180)\n            dt: Datetime (UTC)\n        \n        Returns:\n            dict with 'altitude', 'azimuth', 'angle', 'phase'\n        \"\"\"\n        # Julian day\n        jd = self._julian_day(dt)\n        \n        # Solar coordinates\n        solar_dec = self._solar_declination(jd)\n        eot = self._equation_of_time(jd)\n        \n        # Hour angle\n        time_offset = eot + 4 * lon  # minutes\n        true_solar_time = (dt.hour * 60 + dt.minute + dt.second / 60 + time_offset) % 1440\n        hour_angle = (true_solar_time / 4) - 180 if true_solar_time < 0 else (true_solar_time / 4) - 180\n        \n        # Convert to radians\n        lat_rad = math.radians(lat)\n        dec_rad = math.radians(solar_dec)\n        ha_rad = math.radians(hour_angle)\n        \n        # Solar altitude\n        altitude = math.degrees(math.asin(\n            math.sin(lat_rad) * math.sin(dec_rad) +\n            math.cos(lat_rad) * math.cos(dec_rad) * math.cos(ha_rad)\n        ))\n        \n        # Solar azimuth\n        azimuth = math.degrees(math.acos(\n            (math.sin(dec_rad) - math.sin(lat_rad) * math.sin(math.radians(altitude))) /\n            (math.cos(lat_rad) * math.cos(math.radians(altitude)))\n        ))\n        \n        if hour_angle > 0:\n            azimuth = 360 - azimuth\n        \n        # Determine time phase\n        phase = self._time_phase_from_altitude(altitude)\n        \n        return {\n            \"altitude\": altitude,\n            \"azimuth\": azimuth,\n            \"angle\": azimuth,  # For shadow direction\n            \"phase\": phase,\n        }\n    \n    def sunrise_sunset(\n        self,\n        lat: float,\n        lon: float,\n        date: datetime\n    ) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Calculate sunrise and sunset times.\n        \n        Returns:\n            (sunrise_utc, sunset_utc)\n        \"\"\"\n        # Use iterative approximation\n        # Start with solar noon\n        noon = date.replace(hour=12, minute=0, second=0, microsecond=0)\n        \n        sunrise = self._find_sun_event(lat, lon, noon, rising=True)\n        sunset = self._find_sun_event(lat, lon, noon, rising=False)\n        \n        return sunrise, sunset\n    \n    def season(self, lat: float, dt: datetime) -> Season:\n        \"\"\"\n        Determine current season for given latitude.\n        \n        Handles hemisphere reversal and tropical wet/dry seasons.\n        \"\"\"\n        # Tropical regions (within 23.5Â° of equator) use wet/dry\n        if abs(lat) < 23.5:\n            return self._tropical_season(dt)\n        \n        # Temperate/polar regions use four seasons\n        month = dt.month\n        \n        # Northern hemisphere\n        if lat >= 0:\n            if month in [3, 4, 5]:\n                return Season.SPRING\n            elif month in [6, 7, 8]:\n                return Season.SUMMER\n            elif month in [9, 10, 11]:\n                return Season.AUTUMN\n            else:\n                return Season.WINTER\n        \n        # Southern hemisphere (reversed)\n        else:\n            if month in [3, 4, 5]:\n                return Season.AUTUMN\n            elif month in [6, 7, 8]:\n                return Season.WINTER\n            elif month in [9, 10, 11]:\n                return Season.SPRING\n            else:\n                return Season.SUMMER\n    \n    def season_progress(self, lat: float, dt: datetime) -> float:\n        \"\"\"\n        Return progress through current season (0.0-1.0).\n        \"\"\"\n        season = self.season(lat, dt)\n        month = dt.month\n        day = dt.day\n        \n        # Calculate day of season\n        season_start_months = {\n            Season.SPRING: 3, Season.SUMMER: 6,\n            Season.AUTUMN: 9, Season.WINTER: 12,\n            Season.WET: 5, Season.DRY: 11,\n        }\n        \n        start_month = season_start_months.get(season, 1)\n        days_into_season = (month - start_month) * 30 + day\n        \n        return min(1.0, days_into_season / 90.0)\n    \n    # Private helpers\n    \n    def _julian_day(self, dt: datetime) -> float:\n        \"\"\"Convert datetime to Julian day.\"\"\"\n        a = (14 - dt.month) // 12\n        y = dt.year + 4800 - a\n        m = dt.month + 12 * a - 3\n        \n        jdn = dt.day + (153 * m + 2) // 5 + 365 * y + y // 4 - y // 100 + y // 400 - 32045\n        fraction = (dt.hour + dt.minute / 60 + dt.second / 3600) / 24\n        \n        return jdn + fraction - 0.5\n    \n    def _solar_declination(self, jd: float) -> float:\n        \"\"\"Calculate solar declination angle.\"\"\"\n        n = jd - 2451545.0\n        L = (280.460 + 0.9856474 * n) % 360\n        g = (357.528 + 0.9856003 * n) % 360\n        \n        lambda_sun = L + 1.915 * math.sin(math.radians(g)) + 0.020 * math.sin(2 * math.radians(g))\n        epsilon = 23.439 - 0.0000004 * n\n        \n        return math.degrees(math.asin(math.sin(math.radians(epsilon)) * math.sin(math.radians(lambda_sun))))\n    \n    def _equation_of_time(self, jd: float) -> float:\n        \"\"\"Calculate equation of time (minutes).\"\"\"\n        n = jd - 2451545.0\n        L = (280.460 + 0.9856474 * n) % 360\n        g = (357.528 + 0.9856003 * n) % 360\n        \n        eot = -1.915 * math.sin(math.radians(g)) - 0.020 * math.sin(2 * math.radians(g)) + 2.466 * math.sin(2 * math.radians(L)) - 0.053 * math.sin(4 * math.radians(L))\n        \n        return eot * 4  # Convert to minutes\n    \n    def _time_phase_from_altitude(self, altitude: float) -> TimePhase:\n        \"\"\"Map solar altitude to time phase.\"\"\"\n        if altitude < -18:\n            return TimePhase.DEEP_NIGHT\n        elif altitude < -6:\n            return TimePhase.NIGHT\n        elif altitude < 0:\n            return TimePhase.DUSK if altitude < -3 else TimePhase.DAWN\n        elif altitude < 30:\n            return TimePhase.MORNING\n        else:\n            return TimePhase.AFTERNOON\n    \n    def _find_sun_event(\n        self,\n        lat: float,\n        lon: float,\n        start: datetime,\n        rising: bool\n    ) -> datetime:\n        \"\"\"Find sunrise or sunset time using binary search.\"\"\"\n        # Search window: 12 hours\n        low = start - timedelta(hours=6)\n        high = start + timedelta(hours=6)\n        \n        for _ in range(20):  # Converge to ~1 second accuracy\n            mid = low + (high - low) / 2\n            alt = self.solar_position(lat, lon, mid)[\"altitude\"]\n            \n            if (alt < 0 and rising) or (alt > 0 and not rising):\n                low = mid\n            else:\n                high = mid\n        \n        return (low + high) / 2\n    \n    def _tropical_season(self, dt: datetime) -> Season:\n        \"\"\"Determine wet or dry season for tropics.\"\"\"\n        month = dt.month\n        # Wet season: May-October, Dry season: November-April\n        return Season.WET if 5 <= month <= 10 else Season.DRY\n